# 메모리

## 개요

메모리 계층 구조와 가상 메모리 개념 정리

## 주요 개념

- 메모리 계층
- 캐시
- 가상 메모리

---

## 메모리 계층(**Memory Hierachy)**

메모리 계층은 **레지스터, 캐시, 주기억장치, 보조기억장치**로 구성되어있다.

- **레지스터**: CPU 안에 있는 작은 메모리(휘발성)
- **캐시(L1, L2, L3)**: 대용량의 메인 메모리 접근을 빠르게 하기 위해 CPU 칩 내부나 바로 옆에 탑재하여 데이터나 값을 미리 복사해 놓는 임시 저장소(휘발성)
- **주기억장치(RAM)**: 컴퓨터에서 수치·명령·자료 등을 기억하는 컴퓨터 하드웨어 장치(휘발성)
- **보조 기억 장치(HDD, SDD)**: 주기억장치의 기억 용량을 보조하거나 데이터를 영구 저장하기 위한 기억 장치(비휘발성)

<img width="500" margin="10" alt="image" src="https://github.com/minsu111/basic-computer-science/assets/124219344/dbc3c3a3-1fb4-4e23-b85b-d654481e7fde">

- CPU와 가까운 저장 장치는 빠르고, 멀리 있는 저장 장치는 느리다.
- 속도가 빠른 저장 장치는 저장 용량이 작고, 가격이 비싸며 사용 빈도가 높다.
- 속도가 느린 저장 장치는 저장 용량이 크고, 가격이 저렴하며 사용 빈도가 더 낮다.
  → ‘CPU에 얼마나 가까운가’를 기준으로 계층적으로 나타낼 수 있다.

### 메모리 계층 구조의 필요성

1. **자주 쓰는 데이터는 계속 자주 쓰인다. (참조의 지역성)**
   - 큰 용량의 메모리를 사용해도 그 안의 모든 데이터에 고르게 접근하지 않음.
   - 자주 쓰이는 데이터는 전체 데이터 양에 비해 작은 양이므로 자주 쓰이는 데이터를 저장하는 저장소는 그 아래 계층의 저장소보다 작아도 됨. (캐시<메모리<하드디스크)
2. **경제성**
   - 값이 비싼 장치는 꼭 필요한 만큼의 크기만 사용함.
   - 값이 싼 장치는 넉넉하게 사용함.
3. **디코딩 속도**
   - 큰 메모리 용량을 사용할 경우 디코딩하는 데 더 많은 시간이 소요됨.
     - CPU가 빠르게 데이터에 접근하기 위해서는 데이터를 저장하는 메모리의 용량이 작아야 함.

---

## 캐시(Cache)

캐시는 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말한다.

메모리와 CPU 사이의 속도차가 너무 커서 그 중간에 레지스터 계층을 둬서 속도 차이를 해결한다.
이렇게 속도 차이를 해결하기 위해 계층과 계층 사이에 있는 계층을 **캐싱 계층**이라고 한다.

_e.g. 캐시 메모리와 보조기억장치 사이에 있는 **주기억 장치**는 **보조기억장치의 캐싱 계층**이다._

### 참조 지역성의 원리(Locality of Reference)

> CPU가 메모리에 접근할 때의 주된 경향을 바탕으로 만들어진 원리.

- **시간 지역성(Temporal Locality)**
  - CPU는 **최근에 접근했던 메모리 공간**에 다시 접근하려는 경향이 있다.
- **공간 지역성(Spatial Locality)**
  - CPU는 **접근한 메모리 공간 근처**를 접근하려는 경향이 있다.

→ 참조 지역성의 원리를 따라야 캐시 적중률을 높일 수 있고, 캐시 적중률을 성능과도 직결된다.

\*_캐시 적중률 = 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)_

### 캐시히트와 캐시미스

- **캐시히트:** CPU가 캐시에서 원하는 데이터를 찾은 것.
- **캐시미스:** CPU가 캐시에서 원하는 데이터를 찾지 못해 주 메모리로 가서 데이터를 찾아오는 것.

### **캐시매핑**

- **직접 매핑(Direct Mapping)**
  - 메모리 주소와 캐시의 **순서를 일치시킴**
  - 구현이 비교적 간단하지만 **충돌이 잦고 캐시 적중률이 낮음**
- **연관 매핑(Associative Mapping)**
  - 메모리 주소와 캐시의 **순서를 일치시키지 않음**
  - **관련 있는 캐시와 메모리**를 매핑함
  - 충돌이 적고 적중률이 높지만 **탐색 속도가 느림**
- **직접 연관 매핑(Set Associative Mapping)**
  - 직접 매핑과 연관 매핑을 합쳐 놓은 방식 (두 방식의 장점을 모두 취하는 형태)
  - 순서는 일치시키지만 집합을 둬서 저장하며 블록화되어 있기 때문에 **검색이 보다 효율적임**

### 웹 브라우저의 캐시

**HTTP**는 **비연결성, 무상태성**의 특징을 가지고 있기 때문에 클라이언트가 서버에 데이터를 요청하고 응답을 받게 되면 연결이 끊기며 다음 요청 시 서버는 클라이언트를 식별하지 못한다.
해당 현상을 보완하기 위해 쿠키와 웹스토리지를 사용한다.

- **쿠키: 브라우저에 저장되는 key와 value로 이루어진 작은 크기의 문자열**

  - 만료기한이 있는 키-값 저장소
  - 클라이언트에서 서버로 데이터 요청 시 서버 측에서 쿠키를 생성하여 응답과 함꼐 클라이언트에 넘겨줌
  - 4KB의 크기 제한이 있으며 만료 시간 설정 가능함
  - HTTP 요청 시 따로 설정하지 않아도 자동으로 전달됨

<img width="500" alt="image" src="https://github.com/minsu111/basic-computer-science/assets/124219344/07db3000-11d0-49b8-bb38-becf3976c943">

- **웹 스토리지: 브라우저에 데이터를 저장할 수 있는 API(HTTP5부터 지원)**

  - [**로컬 스토리지**](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)

    - 만료기한이 없는 키-값 저장소
    - 5~10MB까지 저장 가능
    - 웹 브라우저 닫아도 유지됨

  - **[세션 스토리지](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage)**
    - 만료기한이 없는 키-값 저장소
    - 탭 단위로 세션 스토리지 생성 → 탭 닫을 때 해당 데이터 삭제됨
    - 5~10MB까지 저장 가능

  **표로 보는 차이점**

|                    | 쿠키            | 로컬 스토리지                        | 세션 스토리지                        |
| ------------------ | --------------- | ------------------------------------ | ------------------------------------ |
| 용량               | 4KB             | 데스크탑: 5M ~ 10MB<br>모바일: 2.5MB | 데스크탑: 5M ~ 10MB<br>모바일: 2.5MB |
| 브라우저           | HTML4+5         | HTML5                                | HTML5                                |
| 엑세스 가능        | 모든 창         | 모든 창                              | 같은 탭                              |
| 만료               | 수동 설정       | 영구적                               | 탭 닫기                              |
| 접근               | 클라이언트+서버 | 클라이언트                           | 클라이언트                           |
| 요청과 함께 전송됨 | O               | X                                    | X                                    |

---

## 가상 메모리(Virtual Memory)

가상 메모리는 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 말한다.

<br>
<img width="500" alt="image" src="https://github.com/minsu111/basic-computer-science/assets/124219344/6b62dcdf-fe81-4df1-bcdd-6db1f3951734">
<br>

### 가상 메모리의 등장 배경

기존에는 프로세스를 실행하기 위해 실행 코드 전체를 메모리에 로드해야 했고, 메모리 용량보다 더 큰 프로그램은 실행할 수 없었다. 즉 프로세스가 실행되려면 각 프로세스마다 충분한 메모리를 할당받아야 했다.
통상적인 메모리는 8GB 또는 16GB인데, 멀티 프로세스로 프로그램을 실행시킨다고 가정했을 때 동시에 실행할 수 있는 프로세스 개수의 제한이 컸다. 더 많은 프로세스를 동시에 실행하려면 더 큰 메모리 용량이 필요한데, 이는 비용적인 한계가 있다.
프로세스의 실행 코드는 자주 사용되지 않는 방어 코드나 관리 코드가 많아, 실제로는 코드의 일부에서만 대부분의 시간을 사용하고 특정 순간에 더 작은 양의 주소 공간을 사용하기 때문에 이러한 방식은 매우 비효율적이었다.
가상 메모리는 이러한 물리 메모리 크기의 한계를 극복하기 위해 나온 기술이다.

### 주소 바인딩

가상적으로 주어진 주소를 **가상 주소(Logical address)**라고 하며, 실제 메모리상에 존재하는 주소를 **물리 주소(Physical address)**라고 한다.

- **가상 주소 (Logical address)**
  - 프로세스마다 독립적으로 가지는 주소 공간
  - 각 프로세스마다 0번지부터 시작
  - CPU가 바라보는 주소
- **물리 주소 (Physical address)**
  - 메모리에 실제 올라가는 위치
  - 베이스 레지스터에 논리 주소를 더한 값

**주소 바인딩**은 물리 메모리 주소를 결정하는 것을 말하며, 각 프로그램이 가지고 있던 논리적 주소가 물리적 주소로 언제 결정되는가에 따라 세 가지 형태로 나뉜다.

- **컴파일 타임 바인딩**
  - 컴파일 시점에 물리 주소가 결정되는 것 (물리 주소가 컴파일 시 알려짐)
  - 시작 위치 변경 시 재컴파일
  - 컴파일러는 절대 코드를 생성
    _컴퓨터 안에서 프로그램이 하나만 실행되는 환경에서 쓰였음_
- **로드 타임 바인딩**
  - 프로그램 실행이 시작되고 메모리에 올라갈 때 물리 주소가 결정되는 것 (컴파일 타임에는 논리 주소만 결정된 상태)
  - 로더가 메모리 주소를 부여하고 프로그램이 종료될 때까지 물리 주소 고정됨
  - 비어있는 위치를 실행시에 어느 위치든 올라갈 수 있음
- **런 타임 바인딩(실행 시간 바인딩)**
  - 프로그램이 실행된 이후에도 프로세스의 메모리 상 위치를 옮길 수 있음
  - CPU가 주소를 참조(요청)할 때마다 바인딩을 점검함
  - 주소변환용 하드웨어 지원이 필요함 → MMU

### MMU **(Memory Management Unit)**

> 가상 주소를 물리 주소로 매핑해주는 하드웨어 장치

가상 메모리를 사용하려면 런 타임 바인딩을 해야하기 때문에 주소변환용 하드웨어인 MMU가 필요하다. 가상 메모리의 논리 주소로 실제 메모리에 접근하기 위해 빠른 주소 변환이 필요한데, 이를 MMU가 도와준다.

MMU는 논리 주소와 베이스 레지스터 값을 더하여 논리 주소를 물리 주소로 변환한다.

<img width="500" alt="image" src="https://github.com/minsu111/basic-computer-science/assets/124219344/2e812295-bd23-4bd1-81ab-d778666d34ab">

- **베이스 레지스터**
  - 물리 주소의 시작점(최솟값)을 저장
- **한계 레지스터**
  - 논리 주소의 최댓값을 저장
  - 한계 레지스터의 값보다 큰 주소를 참조할 수 없게하여 프로그램 영역을 침벌할 수 있는 명령어의 실행을 막는다.(메모리 보호)
  - `베이스 레지스터 값 ≤ 프로그램의 물리 주소 범위 ≤ 베이스 레지스터 + 한계 레지스터 값`

<img width="500" alt="image" src="https://github.com/minsu111/basic-computer-science/assets/124219344/ffc16169-394f-4180-a4e7-2b6858de6858">

### 페이지 테이블과 TLB

- **페이지 테이블**

  - 가상 주소와 물리 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 테이블
  - 물리 주소에 프로세스가 불연속적으로 배치되더라도 논리 주소에는 연속적으로 배치되도록 하는 방법으로, 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표 역할을함
  - 페이지 테이블에 담기는 정보

    - 페이지 번호/프레임 번호
    - 유효 비트(valid bit): 현재 해당 페이지에 대한 접근 가능 여부.(메모리에 적재되어 있는지 확인) - 0(불가능), 1(가능)로 구분됨.
      - 유효 비트가 0인 페이지에 접근하려고 하면 페이지 폴트가 발생함
    - 보호 비트 : 페이지에 접근할 권한을 제한해서 페이지를 보호함
    - 참조 비트: CPU가 해당 페이지에 접근한 적이 있는지에 대한 여부
    - 수정 비트: CPU가 이 페이지에 데이터를 쓴 적이 있는지에 대한 여부(스와핑 때문에 존재)

페이지를 참조하기 위해 1회, 총 2회 메모리에 접근하게 된다. 이로 인해 메모리 접근 시간이 두 배가 됨.\*\*

- **TLB**
  - 메모리와 CPU 사이에 있는 테이블의 캐시 메모리
  - 페이지 테이블의 일부를 가져와 저장함
  - 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킴
    **→ 불필요한 메모리 접근을 줄일 수 있다.**

<img width="500" alt="image" src="https://github.com/minsu111/basic-computer-science/assets/124219344/e8646635-fd00-4051-b3f4-2cd34807e879">

### 스와핑(Swapping)

스와핑은 현재 사용되지 않는 프로세스들을 보조기억장치의 스왑 영역으로 쫓아내고, 그렇게 해서 생긴 빈 공간에 새 프로세스를 적재하는 것을 말한다.

- **스왑 영역**: RAM의 용량이 가득 차게 될 경우 사용되는 여유 공간. 디스크에 존재하지만 파일 시스템과는 별도로 존재함. (RAM의 확장 개념)
  - 스왑 영역은 외부 저장장치에 존재하기 때문에 스와핑이 발생하면 OS에 의해 IO작업이 일어남
  - 공간효율성보다는 시간효율성을 고려한 저장이 일어나서 일반적으로 파일시스템에 접근하는 것보다 빠름
- **Swap In**: 스왑 영역에서 메모리로 이동하는 것
- **Swap Out**: 메모리에서 스왑 영역을 이동하는 것

### 페이지 폴트(Page Fault)

페이지 폴트는 프로세스의 주소 공간에는 존재하지만 실제 메모리인 RAM에는 없는 데이터나 코드에 접근했을 때 발생한다. 이때 스와핑이 발생하여 마치 페이지 폴트에 대응한다.

페이지 폴트와 그로 인한 스와핑 과정은 다음과 같다.

1. 어떤 명령어가 유효한 가상 주소에 접근했으나 해당 페이지가 메모리상에 없다면 트랩이 발생되어 운영체제에 알린다.
2. 운영체제는 실제 디스크로부터 사용하지 않은 프레임을 찾는다.
3. 해당 프레임을 실제 메모리에 가져와서 페이지 교체 알고리즘을 기반으로 특정 페이지와 교체한다. → **이때 스와핑이 일어남.**
4. 페이지 테이블을 갱신시킨 후 해당 명령어를 다시 시작한다.

**페이지 폴트가 자주 발생하는 이유?**

- 부적절한 페이지 교체 알고리즘을 사용해서
- 프로세스가 사용할 수 있는 프레임 자체가 적어서
  → 그렇기 때문에 메모리가 작은 컴퓨터에 비해 메모리가 큰 컴퓨터가 성능이 좋다.

---

## 스레싱(Thrashing)

스레싱은 메모리의 페이지 폴트율이 높아 프로세스가 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 컴퓨터 성능이 저하되는 문제를 말한다.

스레싱을 해결하기 위한 방법으로는 메모리를 늘리거나 저장장치를 바꾸는 방법이 있으며, 이외 운영체제에서 이를 해결할 수 있는 방법으로는 **작업 세트**와 **PFF**가 있다.

### 작업 세트(Working Set)

프로세스의 과거 사용 이력인 지역성(locality)을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하는 것.

→ 탐색 비용 및 스와핑을 줄일 수 있다.

### PFF(Page Fault Frequency)

페이지 폴트 빈도를 조절하는 방법.

상한선과 하한선을 만들어서 페이지 폴트 빈도가 상한선에 도달하면 프레임을 늘리고, 하한선에 도달하면 프레인을 줄인다.

---

## 메모리 할당

### 연속 할당

- **고정 분할 방식(Fixed partition allocation)**
  - 물리적 메모리를 미리 나누어 관리하는 방식
  - 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되어 있으며 수행 가능한 프로그램의 최대 크기 또한 제한된다는 점에서 가변분할 방식에 비해 융통성이 떨어짐
  - 내부 단편화 발생
- **가변 분할 방식(Variable partition allocation)**

  - 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용
  - 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변함
  - 내부 단편화는 발생하지 않지만 외부 단편화 발생할 수 있음
    가변 분할 방식은 아래 세 가지 할당 방식으로 나뉜다.

  | 이름                | 설명                                                                                                       |
  | ------------------- | ---------------------------------------------------------------------------------------------------------- |
  | 최초적합(first-fit) | 운영체제가 메모리 내의 빈 공간을 검색하다 적재할 수 있는 공간을 발견하면 바로 할당(검색 최소화, 빠른 할당) |
  | 최적적합(best-fit)  | 운영체제가 빈 공간을 모두 검색해본 뒤, 프로세스의 크기 이상인 공간 중 가장 작은 공간에 할당                |
  | 최악적합(worst-fit) | 운영체제가 빈 공간을 모두 검색해본 뒤, 프로세스의 크기 이상인 공간 중 가장 큰 곳에 할당                    |

### **내부 단편화, 외부 단편화란?**

- **내부 단편화 (Internal Fragmentation)**
  필요한 양보다 더 큰 메모리가 할당되어 할당 된 메모리 내부에 사용하지 않는 메모리 공간이 발생하는 현상을 말한다.

  <img width="500" alt="image" src="https://github.com/minsu111/basic-computer-science/assets/124219344/a8308577-dba8-4977-8f67-541375341353">

- **외부 단편화 (External Fragmentation)**
  프로세스들이 실행되고 종료되길 반복하며 메모리 중간중간 빈 공간이 발생한다.
  외부 단편화란 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상을 말한다.

  <img width="500" alt="image" src="https://github.com/minsu111/basic-computer-science/assets/124219344/24dd6a32-6b23-459c-a080-5c90e123a19f">

### 불연속 할당

현대 운영체제에서는 메모리를 연속적으로 할당하지 않는 불연속 할당 방식을 사용하며, 이는 연속 할당의 단점을 보완해주고 가상 메모리 기법 사용을 가능하게 해준다.

- **페이징(paging)**
  - 프로세스의 논리 주소 공간을 가상 메모리를 사용하는 최소 크기 단위인 **페이지**라는 일정 단위로 자르고 메모리의 물리 주소 공간을 페이지와 동일한 일정 단위인 **프레임**으로 자른 뒤, 페이지를 프레임에 할당하는 가상 메모리 관리 기법
  - 외부 단편화 거의 발생하지 않음
  - 페이지 단위의 스와핑 - 페이지 인, 페이지 아웃
    - 프로세스를 실행하는 데 해당 프로세스를 이루고 있는 모든 페이지가 반드시 필요한 것은 아니기 때문에 스와핑을 통해 메모리를 효율적으로 사용함 (물리 메모리보다 큰 프로세스를 실행할 수 있음)
- **세그멘테이션(segmentation)**
- **페이지드 세그멘테이션(paged segmentation)**

---

## 페이지 교체 알고리즘

페이지를 적재하다 보면 메모리가 가득 차게 되고, 당장 실행에 필요한 페이지를 적재하려면 적재된 페이지를 보조기억장치로 내보내야 한다. 이 때, **어떤 페이지를 내보낼지 결정**하는 알고리즘을 페이지 교체 알고리즘이라고 한다.

> 🌟 페이지 폴트가 가장 적게 일어나도록(스와핑이 적게 일어나도록) 설계되어야 한다.

### 오프라인 알고리즘

### FIFO(**First in First out**)

- 메모리에 **가장 먼저 올라온 페이지** 교체
- 가장 단순한 방식

<img width="500" alt="image" src="https://github.com/minsu111/basic-computer-science/assets/124219344/549c6b35-46ca-4928-9a94-c7048200f5ce">

→ 프로그램 실행 내내 사용될 페이지는 먼저 적재되었다고 해서 내보내면 안되기 때문에 성능 측면에서 좋은 방식은 아니다.

### LRU(**Least Recently Used**)

- **가장 오랫동안 사용되지 않은 페이지** 교체
- 가장 오래된 페이지라는 것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 한다는 문제점이 있음

<img width="500" alt="image" src="https://github.com/minsu111/basic-computer-science/assets/124219344/33666841-9f0c-4e05-b140-ceca37d86c28">

### NUR(**Not Used Recently**)

- LRU에서 파생된 알고리즘. **clock 알고리즘**이라고도 함.
- **최근에 사용하지 않은 페이지** 교체
- 참조 비트(and 변경비트)를 사용하여 교체 대상 페이지를 찾는다.

  1. 프레임 내 페이지가 참조되면 1로 자동 세팅됨
  2. 페이지 요청이 들어오면 프레임을 시계 방향으로 한 바퀴 돌며 참조되지 않은 페이지의 참조 비트 값을 0으로 바꾼 후 지나감
  3. 참조 비트가 0인 페이지를 만나면 해당 페이지 교체

  <img width="500" alt="image" src="https://github.com/minsu111/basic-computer-science/assets/124219344/6360bb7c-8a79-4313-b1d5-ee87ea965f0a">

### LFU(**Least Frequently Used**)

- 과거 참조 횟수가 가장 적은 페이지를 교체
- Incache-LFU: 메모리에 적재될 때부터 페이지의 횟수를 카운트 하는 방식
- Perfect-LFU: 메모리 적재 여부와 상관 없이 페이지의 과거 총 참조 횟수를 카운트 하는 방식

<img width="500" alt="image" src="https://github.com/minsu111/basic-computer-science/assets/124219344/8bc71208-80ff-4101-8852-c74f81f2fab5">

---

## 관련 용어 & 개념

- **디코딩(Decoding)**: 부호화된 정보를 부호화되기 전으로 되돌리는 처리(복호화)
- **비연결성( Connectionless )**: 클라이언트와 서버가 한 번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어버리는 성질
- **무상태성(Stateless):** Connectionless로 인해 서버기 클라이언트를 식별할 수가 없는 상태

---

## 참고 자료 & 이미지 출처

- 캐시메모리 매핑기법: [https://gguljaem.tistory.com/entry/캐시메모리의-개념과-매핑기법에-대한-설명](https://gguljaem.tistory.com/entry/%EC%BA%90%EC%8B%9C%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EB%A7%A4%ED%95%91%EA%B8%B0%EB%B2%95%EC%97%90-%EB%8C%80%ED%95%9C-%EC%84%A4%EB%AA%85)
- 메모리 계층 구조: [https://velog.io/@yu-jin-song/CS-메모리-계층-구조](https://velog.io/@yu-jin-song/CS-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0)
- 웹 브라우저 캐시
  - [https://youtu.be/c7eLPK9RzEM?si=rG-JIU-WFRDb92Y2](https://youtu.be/c7eLPK9RzEM?si=rG-JIU-WFRDb92Y2)
  - [https://velog.io/@kyeun95/프로젝트-세션스토리지-로컬스토리지-차이점](https://velog.io/@kyeun95/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%84%B8%EC%85%98%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EB%A1%9C%EC%BB%AC%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%B0%A8%EC%9D%B4%EC%A0%90)
  - [https://www.itworld.co.kr/news/102368](https://www.itworld.co.kr/news/102368)
- 가상 메모리
  - [https://namoo-gamedev.tistory.com/28](https://namoo-gamedev.tistory.com/28) (이미지 사용)
  - [https://www.atatus.com/blog/what-is-swap-space/](https://www.atatus.com/blog/what-is-swap-space/)
  - [https://www.youtube.com/watch?v=5pEDL6c--\_k&t=471s](https://www.youtube.com/watch?v=5pEDL6c--_k&t=471s)
  - [https://er.yuvayana.org/memory-fragmentation-in-operating-system/](https://er.yuvayana.org/memory-fragmentation-in-operating-system/) (이미지 사용)
  - [https://ddongwon.tistory.com/49](https://ddongwon.tistory.com/49)(이미지 사용)
  - [https://zangzangs.tistory.com/143](https://zangzangs.tistory.com/143)
- 관련 강의
  - [https://core.ewha.ac.kr/publicview/C0101020140425151219100144?vmode=f](https://core.ewha.ac.kr/publicview/C0101020140425151219100144?vmode=f)
  - [https://www.inflearn.com/course/lecture?courseSlug=혼자-공부하는-컴퓨터구조-운영체제&unitId=149167&tab=curriculum](https://www.inflearn.com/course/lecture?courseSlug=%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C&unitId=149167&tab=curriculum)
