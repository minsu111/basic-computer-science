### 4주 차

<details>
<summary>데이터베이스의 관계(Relationship)에 대해 설명해 주세요.</summary>

### 👨🏻‍💻 **답변**

```
테이블 관계의 종류에는 1:1 관계, 1:N 관계, N:M 관계가 있습니다.
1:1 관계는 하나의 레코드가 다른 테이블의 레코드 한 개와 연결된 경우를 말합니다.
1:N 관계는 하나의 레코드가 서로 다른 여러 개의 레코드와 연결된 경우를 말합니다.
N:M(다대다) 관계는 여러 개의 레코드가 다른 테이블의 여러 개의 레코드와 연결된 경우를 말합니다.
N:M 관겨의 경우 1:N(일대다) 관계와 비슷하지만, 양방향에서 다수의 레코드를 가질 수 있다는 특징이 있습니다.
```

### 🎯 **핵심 키워드**

```
테이블, 레코드, 연결, 양방향
```

### 📔 **관련 자료**

- [1. 데이터베이스의 기본](1.%20데이터베이스의%20기본.md)

</details>

<details>
<summary>데이터베이스에서 키의 종류에 대해 설명해주세요.</summary>

### 👨🏻‍💻 **답변**

```
키의 종류에는 슈퍼키, 기본키, 후보키, 대체키, 외래키가 있습니다.
먼저 슈퍼키는 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키입니다.
기본키는 유일성과 최소성을 모두 만족하는 키입니다.
여기서 최소성이란 속성들 중 가장 최소로 필요한 속성들로만 키를 구성하는 성질을 뜻합니다.
기본키가 될 수 있는 모든 키를 후보키라고 하며,
기본키를 제외한 나머지 후보키들을 대체키라고 합니다.
외래키는 다른 테이블의 기본키를 그대로 참조하는 값을 말합니다.
```

### 🎯 **핵심 키워드**

```
유일성, 최소성, 참조
```

### 📔 **관련 자료**

- [1. 데이터베이스의 기본](1.%20데이터베이스의%20기본.md)

</details>

<details>
<summary>정규화 과정에서 제1정규형부터 제3정규형까지 설명해주세요.</summary>

### 👨🏻‍💻 **답변**

```
제1정규형(1NF)은 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값만으로 구성된 형태입니다.
제2정규형(2NF)은 제1정규형을 만족하면서, 부분 함수적 종속성을 제거하여 기본키에 속하지 않은 모든 속성이 기본키에 완전 함수적 종속 관계를 가지는 형태입니다.
제3정규형(3NF)은 제2정규형을 만족하면서 기본키가 아닌 모든 속성이 이행적 함수적 종속을 만족하지 않는 형태입니다.
```

### 🎯 **핵심 키워드**

```
원자 값, 부분 함수적 종속성, 완전 함수적 종속, 이행 함수적 종속
```

### 📔 **관련 자료**

- [2. ERD와 정규화 과정](2.%20ERD와%20정규화%20과정.md)

</details>

<details>
<summary>격리 수준에 따라 발생하는 현상 세 가지를 설명해주세요.</summary>

### 👨🏻‍💻 **답변**

```
격리 수준에 따라 발생하는 현상에는 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드가 있습니다.
팬텀 리드는 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우를 말합니다.
반복 가능하지 않은 조회는 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우를 말합니다. 반복 가능하지 않은 조회는 행 값이 달라질 수 있는데, 팬텀 리드는 다른 행이 선택될 수도 있다는 차이점이 있습니다.
더티 리드는 한 트랙잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 행의 데이터를 읽는 경우를 말합니다.
```

### 🎯 **핵심 키워드**

```
트랜잭션, 쿼리, 데이터
```

### 📔 **관련 자료**

- [3. 트랜잭션과 무결성](1.%20트랜잭션과%20무결성.md)

</details>

### 5주 차

<details>
<summary>관계형 데이터베이스(RDBMS)와 NoSQL의 차이점을 설명해주세요.</summary>

### 👨🏻‍💻 **답변**

```
관계형 데이터베이스는 정적 스키마를 통해 미리 정의된 데이터 구조에 따라 데이터를 저장하는 반면,
NoSQL은 스키마를 정의해두지 않고 데이터를 삽입하는 동적 스키마를 사용합니다.
또한 관계형 데이터베이스는 스케일링에 제약이 있어 데이터베이스를 여러 서버에 분산하여 처리량과 성능을 향상시키는 수평적 확장이 어렵고,
NoSQL은 수평적 확장이 비교적 쉽습니다.
관계형 데이터베이스는 데이터 무결성을 높이는 데 유리하며, NoSQL은 스키마가 유연하지만 데이터 중복의 위험이 있습니다.
```

### 🎯 **핵심 키워드**

```
스키마, 수평적 확장, 데이터 무결성, 데이터 중복
```

### 📔 **관련 자료**

- [5. 인덱스](4.데이터베이스의%20종류.md)

</details>

<details>
<summary>인덱스가 효율적인 이유를 설명해주세요.</summary>

### 👨🏻‍💻 **답변**

```
인덱스는 특정 조건을 만족하는 레코드를 빠르게 조회하기 위해 사용합니다.
인덱스가 효율적인 이유는, 효율적인 단계를 거쳐 모든 요소에 접근할 수있는 균형 잡힌 트리 구조로 되어있으며
트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 특성인 대수확장성을 가지고 있기 때문입니다.
```

### 🎯 **핵심 키워드**

```
균형 잡힌 트리 구조, 대수확장성
```

### 📔 **관련 자료**

- [5. 인덱스](5.%20인덱스.md)

</details>

<details>
<summary>인덱스를 사용하는 것보다 full table scan이 더 효율적인 경우를 말해주세요.</summary>

### 👨🏻‍💻 **답변**

```
테이블의 전체 데이터 수가 너무 적거나, 조회하려는 데이터가 테이블의 상당 부분을 차지할 때는
인덱스를 사용하는 것보다 full table scan을 하는 것이 더 효율적입니다.
이 경우 인덱스가 존재하더라도 DBMS의 optimizer 판단 하에 full table scan을 진행하기도 합니다.
```

### 🎯 **핵심 키워드**

```
데이터 수
```

### 📔 **관련 자료**

- [5. 인덱스](5.%20인덱스.md)

</details>

<details>
<summary>조인의 종류에 대해 설명해주세요.</summary>

### 👨🏻‍💻 **답변**

```
대표적인 조인의 종류로는 크게 Inner Join과 Outer Join이 있습니다.
Inner 조인은 두 테이블에서 조인 조건에 일치하는 레코드로만 결과 테이블을 만드는 방식입니다.
Outer Join은 조인 조건을 만족하지 않는 레코드(튜플)들도 결과 테이블에 포함하는 조인 방식으로,
Left Outer Join, Right Outer Join, Full Outer Join으로 나뉩니다.
Left Outer Join은 조인문 왼쪽 테이블의 모든 결과를 가져와서 오른쪽 테이블의 데이터와 매칭하고,
매칭되는 데이터가 없는 경우 null로 표시합니다.
Right Outer Join은 반대로 조인문 오른쪽 테이블의 모든 결과를 가져와서 왼쪽 테이블의 데이터와 매칭하고,
매칭되는 데이터가 없는 경우 null로 표시합니다.
Full Outer Join은 양쪽 모두 조인 조건에 부합하지 않는 레드코들까지도 결과 테이블에 포함합니다.
```

### 🎯 **핵심 키워드**

```
Inner Join, Outer Join, 조인 조건, null
```

### 📔 **관련 자료**

- [6. 조인의 종류](6.%20조인의%20종류.md)

</details>
